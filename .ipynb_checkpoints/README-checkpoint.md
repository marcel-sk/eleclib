# Purpose
To create a python utility to simplify electrical and off-grid load calculations.\
I find myself writing short scripts to run various calculations quite frequently and figured I should create something more versatile and reusable that could hel others interested in off-grid power solutions!
Currently only the household load calculator is functional- see Module household

### This will eventually include:
* conductor sizing
* household load calculation
* solar, wind, and hydro considerations
* battery sizing
* pricing
* ... unfinished list ...

# Module household
## Class Household
You can create a Household object in order to call various accessors and reporter methods. The Household class will hold a list of appliances which will each contribute to the total load as well as information about the building, number of occupants and location.
### Getting Started
There are three ways to create a Household object:
1. You can create a new Household object programatically by supplying all or most inputs. The rest of the inputs will remain at their default values which should resemble average or typical values.
2. You can create a Household object without arguments, and call its prompt_for_args() method to alter the default values:

>from electriclib.household import Household\
>myHouse = Household()\
>myHouse.prompt_for_args()

3. You can load in an excel file as generated by the Household.report() method in a previous session.

>myHouse.report("report.xlsx")\
>newHouse = Household(file_source = "./report.xlsx")

### __init__(self,**kwargs):

| param | default | description |
| :--- | :--- | :---
|square_footage|6000|Int- total household square footage
|R_roof|30|INT- 0 to 100 Average R-value of the roof default is from building code for Ontario as of 2021
|R_walls|24|INT- 0 to 100 Average R-value of the walls. default is from building code for Ontario as of 2021
|off_grid| False | Bool- is the house off-grid in the sense of not being connected to a municipal power grid.
|occupants|3|Int- 0 to 100. Number of permanent occupants. Used to determine water usage, lighting, etc.
|appliances|["heater", "water heater", "fridge", "lights", "pump", "oven"]|list of str or Apliance specifying which appliances are in the household.

### Public Methods:

**get_peak_current()**  
Returns the peak current in Amps. This is often needed in sizing panels, main lines, and ogg grid components like batteries and fuses.

**get_power_consumption()**  
Returns power usage in Killowatt hours. You can use this with peak=True and timespan=1, to get the peak daily value which is a useful number in calculating off grid requirements like battery capacity and power production from solar, wind, or hydro.

>myHouse.get_power_usage(1, peak=True)

| Inputs | Default | Required | Description
| :--- | :--- | :--- | :---
| timespan | 1 | True | Int- number of days. Defaults to a daily power usage (1) but can be set  to 30 to get monthly (typical billing cycle) or 365 for yearly power usage.
| peak | False | False | Bool- wether to give us the peak value (True) or the average. Default is the average. 

**get_recommendations()**  
Returns recommendations for reducing power consumption. It can suggest things like switching an appliance to 12V from 120V if it is more efficient (off-grid fridge).

**__str__()**  
>print(str(myHouse))

Shows all configurations for Household

**report()**  
Generates a report so that the info can be used and viewed later. Supports only the xlsx format at the moment.

| Inputs | Default | Required | Description
| :--- | :--- | :--- | :---
| file_path | "./report.xlsx" | True | String- File path for the generated report. Only supports xlsx at the moment.


### TODO

* separate Household into separate objects for each appliance
* finish writing tests

# Class Appliance:

A **household.Appliance** is defined by name, power type, wattage and usage.
These values in turn let us calculate its contribution to total
current draw and power consumption for a Household.

### USAGE:
Private class used only by its children.
See Subclasses
* Fridge
* Oven
* Heater
* WaterHeater
* Lights
* Pump
All Subclasses can be called without parameters and set up via command prompt
>myFridge = Fridge()\
>myFridge.prompt()

For programmatic setup see individual subclasses for full descriptions

### TODO: 
* appliances are not all interchangeable, different appliances rely on different values to get wattage and daily_usage...
* create a AustomAppliance class that can be used to create an appliance that has not been added already. This should not need certain values like types and default values.
* when prompting "" should leave the current value rather than set the default?
* add support for propane/gas type appliances to calculate volumetric usage

# Class Oven
An Oven is a typical appliance in that it is easily defined by 
a running wattage and daily usage from which power and current
draw can be easily calculated.

### USAGE:
You can either initialize Oven without parameters and set the 
relevant values through the command prompt:
>myOven = Oven()
>myOven.prompt()

OR- You can pass values into the constructor directly. In this case
you should pass in **power_type, wattage, daily_usage**. with values 
defined in watts and hours respectively
>myOven = Oven("electric", 5000, 1)

Finally you can use its various reporting methods:
>print(str(myOven))
>myOven.get_consumption()

### TODO: 
* add in support for electric-toaster @240V and electric @120V? (non-typical)
* scale down consumption to account for the oven not being at full draw the whole time it is being used


# Class Fridge
A fridge typically consumes a stable amount of power year round. 
Its power will be known in terms of kwh/yr or sometimes running watts (less
precise). In the case of watts we can use daily_usage to 
find the kwh/yr value. This value is the actual running time of the
fridge compressor in hours per day.

### USAGE
You can either initialize a Fridge without parameters and set the 
relevant values through the command prompt:
>myFridge = Fridge()\
>myFridge.prompt()

OR- You can pass values into the constructor directly.
>myFridge = Fridge(type = 'electric', wattage = 400, unit = 'kwh/yr')

Finally you can use its various reporting methods:
>print(str(myFridge))\
>myFridge.get_consumption()

### TODO: 
* add support for propane-electric which may be run on propane part of the year and electric the rest.

# Class Heater
A HEATER varies greatly in output based on environmental conditions.
As such defining wattage of an electrical heater is only relevant for 
the purpose of calculating currrent draw, while power consumption is
related to the efficiency of the heater, the temperature outside and 
the building structure.

### USAGE:
You can either initialize a Heater without parameters and set the 
relevant values through the command prompt:
>myHeater = Heater()
>myHeater.prompt()

OR- You can pass values into the constructor directly. In this case
you should pass in\
**[[(power_type, wattage, daily_usage) OR (power_type, wattage, efficiency)]  
AND\
[house OR (square_footage, R_walls, R_roof)]]**  
where efficiency is a percentage, house is of type Household and R-values are full wall construction R values. For example:
>myHouse = Household()
>myHeater = Heater(power_type = 'electric', wattage = 4000, efficiency = 90, house= myHouse)

Finally you can use its various reporting methods:
>print(str(myHeater))
>myFridge.get_consumption() #daily consumption average

### TODO: 
* support for seasonal changes- see get_consumption args
* perfect the get_consumption calculations
* add efficiency to prompt

# Class Lights
Lights will typically produce a relatively stable power consumption 
year round. The amount will typically be dependant on size of a house, 
number of occupants, and type of bulbs used. Since we are treating 
all the lights in a house as a single appliance it makes sense to define
wattage as the average value and use a 24-hour usage to calculate 
consumption.

### USAGE:
You can either initialize Lights without parameters and set the 
relevant values through the command prompt:
>myLights = Lights()
>myLights.prompt()

OR- You can pass values into the constructor directly. In this case
you should pass in at least **square_footage, occupants**
OR **house** where the wattage is a 24-hour average value, and house
is a Household type object.
>myHouse = Household()
>myLights = Lights(house= myHouse)

Finally you can use its various reporting methods:
>print(str(myLights))
>myLights.get_consumption()

### TODO: 
* support different default wattages for diferent bulbs

# Class WaterHeater
An WaterHeater (if electric) will have a known wattage, but the daily_usage 
will be defined by the number of occupants in a Household- much like the Pump
class.

### USAGE:
You can either initialize WaterHeater without parameters and set the 
relevant values through the command prompt:
>myWaterHeater = WaterHeater()
>myWaterHeater.prompt()

OR- You can define it programatically by providing\
**[[wattage]\
AND\
[occupants OR daily_usage OR house]]**  
where daily_usage is pump running time in hours, and house is of type Household
>myhouse = Household()
>myWaterHeater = WaterHeater(wattage=4000, house= myHouse)

Finally you can use its various reporting methods:
>print(str(myWaterHeater))
>myWaterHeater.get_consumption()

### TODO: 
* implement docstrings and generate documentation
* implement __all__ to leave out global module vars (constants) in import *
* use annotations to make inputs more evident?
* make a more thourough set of tests
* make get_power_consumption()
* rewrite the appliances class from scratch...
        * think about which methods should be public (underscore (single) otherwise)
        * make Appliance class very maleable for cases where we don't want to specify wattage- look at how an appliance should be set in general
        * when should functions return False vs throw an error?
        * where should we check to see if an input is None?
* should I use args, and kwargs in appliances?
    this way I could look at what has been supplied and separate into concise constructor blocks...
    
* 79 characters in a line max (up to 99?)